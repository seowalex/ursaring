# generated by datamodel-codegen:
#   filename:  https://api.ynab.com/papi/open_api_spec.yaml

from __future__ import annotations

from datetime import date, datetime
from enum import Enum
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import BaseModel, Field, RootModel
from typing_extensions import Annotated


class ErrorDetail(BaseModel):
    id: str
    name: str
    detail: str


class User(BaseModel):
    id: UUID


class DateFormat(BaseModel):
    """
    The date format setting for the budget.  In some cases the format will not be available and will be specified as null.
    """

    format: str


class CurrencyFormat(BaseModel):
    """
    The currency format setting for the budget.  In some cases the format will not be available and will be specified as null.
    """

    iso_code: str
    example_format: str
    decimal_digits: int
    decimal_separator: str
    symbol_first: bool
    group_separator: str
    currency_symbol: str
    display_symbol: bool


class BudgetSettings(BaseModel):
    date_format: DateFormat
    currency_format: CurrencyFormat


class LoanAccountPeriodicValue(RootModel[Optional[Dict[str, int]]]):
    root: Optional[Dict[str, int]] = None


class AccountType(Enum):
    """
    The type of account
    """

    CHECKING = 'checking'
    SAVINGS = 'savings'
    CASH = 'cash'
    CREDIT_CARD = 'creditCard'
    LINE_OF_CREDIT = 'lineOfCredit'
    OTHER_ASSET = 'otherAsset'
    OTHER_LIABILITY = 'otherLiability'
    MORTGAGE = 'mortgage'
    AUTO_LOAN = 'autoLoan'
    STUDENT_LOAN = 'studentLoan'
    PERSONAL_LOAN = 'personalLoan'
    MEDICAL_DEBT = 'medicalDebt'
    OTHER_DEBT = 'otherDebt'


class CategoryGroup(BaseModel):
    id: UUID
    name: str
    hidden: Annotated[
        bool, Field(description='Whether or not the category group is hidden')
    ]
    deleted: Annotated[
        bool,
        Field(
            description='Whether or not the category group has been deleted.  Deleted category groups will only be included in delta requests.'
        ),
    ]


class GoalTypeEnum(Enum):
    """
    The type of goal, if the category has a goal (TB='Target Category Balance', TBD='Target Category Balance by Date', MF='Monthly Funding', NEED='Plan Your Spending')
    """

    TB = 'TB'
    TBD = 'TBD'
    MF = 'MF'
    NEED = 'NEED'
    DEBT = 'DEBT'


class GoalType(RootModel[Optional[GoalTypeEnum]]):
    root: Annotated[
        Optional[GoalTypeEnum],
        Field(
            description="The type of goal, if the category has a goal (TB='Target Category Balance', TBD='Target Category Balance by Date', MF='Monthly Funding', NEED='Plan Your Spending')"
        ),
    ] = None


class Category(BaseModel):
    id: UUID
    category_group_id: UUID
    category_group_name: Optional[str] = None
    name: str
    hidden: Annotated[bool, Field(description='Whether or not the category is hidden')]
    original_category_group_id: Annotated[
        Optional[UUID],
        Field(description='DEPRECATED: No longer used.  Value will always be null.'),
    ] = None
    note: Optional[str] = None
    budgeted: Annotated[int, Field(description='Budgeted amount in milliunits format')]
    activity: Annotated[int, Field(description='Activity amount in milliunits format')]
    balance: Annotated[int, Field(description='Balance in milliunits format')]
    goal_type: Annotated[
        Optional[GoalType],
        Field(
            description="The type of goal, if the category has a goal (TB='Target Category Balance', TBD='Target Category Balance by Date', MF='Monthly Funding', NEED='Plan Your Spending')"
        ),
    ] = None
    goal_needs_whole_amount: Annotated[
        Optional[bool],
        Field(
            description='Indicates the monthly rollover behavior for "NEED"-type goals. When "true", the goal will always ask for the target amount in the new month ("Set Aside"). When "false", previous month category funding is used ("Refill"). For other goal types, this field will be null.'
        ),
    ] = None
    goal_day: Annotated[
        Optional[int],
        Field(
            description="A day offset modifier for the goal's due date. When goal_cadence is 2 (Weekly), this value specifies which day of the week the goal is due (0 = Sunday, 6 = Saturday). Otherwise, this value specifies which day of the month the goal is due (1 = 1st, 31 = 31st, null = Last day of Month)."
        ),
    ] = None
    goal_cadence: Annotated[
        Optional[int],
        Field(
            description="The goal cadence. Value in range 0-14. There are two subsets of these values which behave differently. For values 0, 1, 2, and 13, the goal's due date repeats every goal_cadence * goal_cadence_frequency, where 0 = None, 1 = Monthly, 2 = Weekly, and 13 = Yearly. For example, goal_cadence 1 with goal_cadence_frequency 2 means the goal is due every other month. For values 3-12 and 14, goal_cadence_frequency is ignored and the goal's due date repeats every goal_cadence, where 3 = Every 2 Months, 4 = Every 3 Months, ..., 12 = Every 11 Months, and 14 = Every 2 Years."
        ),
    ] = None
    goal_cadence_frequency: Annotated[
        Optional[int],
        Field(
            description="The goal cadence frequency. When goal_cadence is 0, 1, 2, or 13, a goal's due date repeats every goal_cadence * goal_cadence_frequency. For example, goal_cadence 1 with goal_cadence_frequency 2 means the goal is due every other month.  When goal_cadence is 3-12 or 14, goal_cadence_frequency is ignored."
        ),
    ] = None
    goal_creation_month: Annotated[
        Optional[date], Field(description='The month a goal was created')
    ] = None
    goal_target: Annotated[
        Optional[int], Field(description='The goal target amount in milliunits')
    ] = None
    goal_target_month: Annotated[
        Optional[date],
        Field(
            description='The original target month for the goal to be completed.  Only some goal types specify this date.'
        ),
    ] = None
    goal_percentage_complete: Annotated[
        Optional[int], Field(description='The percentage completion of the goal')
    ] = None
    goal_months_to_budget: Annotated[
        Optional[int],
        Field(
            description='The number of months, including the current month, left in the current goal period.'
        ),
    ] = None
    goal_under_funded: Annotated[
        Optional[int],
        Field(
            description="The amount of funding still needed in the current month to stay on track towards completing the goal within the current goal period. This amount will generally correspond to the 'Underfunded' amount in the web and mobile clients except when viewing a category with a Needed for Spending Goal in a future month.  The web and mobile clients will ignore any funding from a prior goal period when viewing category with a Needed for Spending Goal in a future month."
        ),
    ] = None
    goal_overall_funded: Annotated[
        Optional[int],
        Field(
            description='The total amount funded towards the goal within the current goal period.'
        ),
    ] = None
    goal_overall_left: Annotated[
        Optional[int],
        Field(
            description='The amount of funding still needed to complete the goal within the current goal period.'
        ),
    ] = None
    deleted: Annotated[
        bool,
        Field(
            description='Whether or not the category has been deleted.  Deleted categories will only be included in delta requests.'
        ),
    ]


class Data8(BaseModel):
    category: Category
    server_knowledge: Annotated[int, Field(description='The knowledge of the server')]


class SaveCategoryResponse(BaseModel):
    data: Data8


class Payee(BaseModel):
    id: UUID
    name: str
    transfer_account_id: Annotated[
        Optional[str],
        Field(
            description='If a transfer payee, the `account_id` to which this payee transfers to'
        ),
    ] = None
    deleted: Annotated[
        bool,
        Field(
            description='Whether or not the payee has been deleted.  Deleted payees will only be included in delta requests.'
        ),
    ]


class PayeeLocation(BaseModel):
    id: UUID
    payee_id: UUID
    latitude: str
    longitude: str
    deleted: Annotated[
        bool,
        Field(
            description='Whether or not the payee location has been deleted.  Deleted payee locations will only be included in delta requests.'
        ),
    ]


class SaveSubTransaction(BaseModel):
    amount: Annotated[
        int, Field(description='The subtransaction amount in milliunits format.')
    ]
    payee_id: Annotated[
        Optional[UUID], Field(description='The payee for the subtransaction.')
    ] = None
    payee_name: Annotated[
        Optional[str],
        Field(
            description='The payee name.  If a `payee_name` value is provided and `payee_id` has a null value, the `payee_name` value will be used to resolve the payee by either (1) a matching payee rename rule (only if import_id is also specified on parent transaction) or (2) a payee with the same name or (3) creation of a new payee.',
            max_length=200,
        ),
    ] = None
    category_id: Annotated[
        Optional[UUID],
        Field(
            description='The category for the subtransaction.  Credit Card Payment categories are not permitted and will be ignored if supplied.'
        ),
    ] = None
    memo: Annotated[Optional[str], Field(max_length=500)] = None


class DebtTransactionTypeEnum(Enum):
    """
    If the transaction is a debt/loan account transaction, the type of transaction
    """

    PAYMENT = 'payment'
    REFUND = 'refund'
    FEE = 'fee'
    INTEREST = 'interest'
    ESCROW = 'escrow'
    BALANCE_ADJUSTMENT = 'balanceAdjustment'
    CREDIT = 'credit'
    CHARGE = 'charge'


class DebtTransactionType(RootModel[Optional[DebtTransactionTypeEnum]]):
    root: Annotated[
        Optional[DebtTransactionTypeEnum],
        Field(
            description='If the transaction is a debt/loan account transaction, the type of transaction'
        ),
    ] = None


class Type(Enum):
    """
    Whether the hybrid transaction represents a regular transaction or a subtransaction
    """

    TRANSACTION = 'transaction'
    SUBTRANSACTION = 'subtransaction'


class SavePayee(BaseModel):
    name: Annotated[
        Optional[str],
        Field(
            description='The name of the payee. The name must be a maximum of 500 characters.',
            max_length=500,
        ),
    ] = None


class SaveCategory(BaseModel):
    name: Optional[str] = None
    note: Optional[str] = None
    category_group_id: Optional[UUID] = None


class SaveMonthCategory(BaseModel):
    budgeted: Annotated[int, Field(description='Budgeted amount in milliunits format')]


class Data18(BaseModel):
    transaction_ids: Annotated[
        List[str], Field(description='The list of transaction ids that were imported.')
    ]


class TransactionsImportResponse(BaseModel):
    data: Data18


class Bulk(BaseModel):
    transaction_ids: Annotated[
        List[str], Field(description='The list of Transaction ids that were created.')
    ]
    duplicate_import_ids: Annotated[
        List[str],
        Field(
            description='If any Transactions were not created because they had an `import_id` matching a transaction already on the same account, the specified import_id(s) will be included in this list.'
        ),
    ]


class Data19(BaseModel):
    bulk: Bulk


class BulkResponse(BaseModel):
    data: Data19


class SubTransaction(BaseModel):
    id: str
    transaction_id: str
    amount: Annotated[
        int, Field(description='The subtransaction amount in milliunits format')
    ]
    memo: Optional[str] = None
    payee_id: Optional[UUID] = None
    payee_name: Optional[str] = None
    category_id: Optional[UUID] = None
    category_name: Optional[str] = None
    transfer_account_id: Annotated[
        Optional[UUID],
        Field(
            description='If a transfer, the account_id which the subtransaction transfers to'
        ),
    ] = None
    transfer_transaction_id: Annotated[
        Optional[str],
        Field(
            description='If a transfer, the id of transaction on the other side of the transfer'
        ),
    ] = None
    deleted: Annotated[
        bool,
        Field(
            description='Whether or not the subtransaction has been deleted.  Deleted subtransactions will only be included in delta requests.'
        ),
    ]


class Frequency(Enum):
    NEVER = 'never'
    DAILY = 'daily'
    WEEKLY = 'weekly'
    EVERY_OTHER_WEEK = 'everyOtherWeek'
    TWICE_A_MONTH = 'twiceAMonth'
    EVERY4_WEEKS = 'every4Weeks'
    MONTHLY = 'monthly'
    EVERY_OTHER_MONTH = 'everyOtherMonth'
    EVERY3_MONTHS = 'every3Months'
    EVERY4_MONTHS = 'every4Months'
    TWICE_A_YEAR = 'twiceAYear'
    YEARLY = 'yearly'
    EVERY_OTHER_YEAR = 'everyOtherYear'


class ScheduledSubTransaction(BaseModel):
    id: UUID
    scheduled_transaction_id: UUID
    amount: Annotated[
        int,
        Field(description='The scheduled subtransaction amount in milliunits format'),
    ]
    memo: Optional[str] = None
    payee_id: Optional[UUID] = None
    category_id: Optional[UUID] = None
    transfer_account_id: Annotated[
        Optional[UUID],
        Field(
            description='If a transfer, the account_id which the scheduled subtransaction transfers to'
        ),
    ] = None
    deleted: Annotated[
        bool,
        Field(
            description='Whether or not the scheduled subtransaction has been deleted. Deleted scheduled subtransactions will only be included in delta requests.'
        ),
    ]


class MonthSummary(BaseModel):
    month: date
    note: Optional[str] = None
    income: Annotated[
        int,
        Field(
            description="The total amount of transactions categorized to 'Inflow: Ready to Assign' in the month"
        ),
    ]
    budgeted: Annotated[
        int, Field(description='The total amount budgeted in the month')
    ]
    activity: Annotated[
        int,
        Field(
            description="The total amount of transactions in the month, excluding those categorized to 'Inflow: Ready to Assign'"
        ),
    ]
    to_be_budgeted: Annotated[
        int, Field(description="The available amount for 'Ready to Assign'")
    ]
    age_of_money: Annotated[
        Optional[int], Field(description='The Age of Money as of the month')
    ] = None
    deleted: Annotated[
        bool,
        Field(
            description='Whether or not the month has been deleted.  Deleted months will only be included in delta requests.'
        ),
    ]


class MonthDetail(MonthSummary):
    categories: Annotated[
        List[Category],
        Field(
            description='The budget month categories.  Amounts (budgeted, activity, balance, etc.) are specific to the {month} parameter specified.'
        ),
    ]


class TransactionFlagColorEnum(Enum):
    """
    The transaction flag
    """

    RED = 'red'
    ORANGE = 'orange'
    YELLOW = 'yellow'
    GREEN = 'green'
    BLUE = 'blue'
    PURPLE = 'purple'


class TransactionFlagColor(RootModel[Optional[TransactionFlagColorEnum]]):
    root: Annotated[
        Optional[TransactionFlagColorEnum], Field(description='The transaction flag')
    ] = None


class TransactionFlagName(RootModel[Optional[str]]):
    root: Annotated[
        Optional[str], Field(description='The customized name of a transaction flag')
    ] = None


class TransactionClearedStatus(Enum):
    """
    The cleared status of the transaction
    """

    CLEARED = 'cleared'
    UNCLEARED = 'uncleared'
    RECONCILED = 'reconciled'


class ScheduledTransactionFrequency(Enum):
    """
    The scheduled transaction frequency
    """

    NEVER = 'never'
    DAILY = 'daily'
    WEEKLY = 'weekly'
    EVERY_OTHER_WEEK = 'everyOtherWeek'
    TWICE_A_MONTH = 'twiceAMonth'
    EVERY4_WEEKS = 'every4Weeks'
    MONTHLY = 'monthly'
    EVERY_OTHER_MONTH = 'everyOtherMonth'
    EVERY3_MONTHS = 'every3Months'
    EVERY4_MONTHS = 'every4Months'
    TWICE_A_YEAR = 'twiceAYear'
    YEARLY = 'yearly'
    EVERY_OTHER_YEAR = 'everyOtherYear'


class ErrorResponse(BaseModel):
    error: ErrorDetail


class Data(BaseModel):
    user: User


class UserResponse(BaseModel):
    data: Data


class Data3(BaseModel):
    settings: BudgetSettings


class BudgetSettingsResponse(BaseModel):
    data: Data3


class Account(BaseModel):
    id: UUID
    name: str
    type: AccountType
    on_budget: Annotated[
        bool, Field(description='Whether this account is on budget or not')
    ]
    closed: Annotated[bool, Field(description='Whether this account is closed or not')]
    note: Optional[str] = None
    balance: Annotated[
        int,
        Field(description='The current balance of the account in milliunits format'),
    ]
    cleared_balance: Annotated[
        int,
        Field(
            description='The current cleared balance of the account in milliunits format'
        ),
    ]
    uncleared_balance: Annotated[
        int,
        Field(
            description='The current uncleared balance of the account in milliunits format'
        ),
    ]
    transfer_payee_id: Annotated[
        UUID,
        Field(
            description='The payee id which should be used when transferring to this account'
        ),
    ]
    direct_import_linked: Annotated[
        Optional[bool],
        Field(
            description='Whether or not the account is linked to a financial institution for automatic transaction import.'
        ),
    ] = None
    direct_import_in_error: Annotated[
        Optional[bool],
        Field(
            description='If an account linked to a financial institution (direct_import_linked=true) and the linked connection is not in a healthy state, this will be true.'
        ),
    ] = None
    last_reconciled_at: Annotated[
        Optional[datetime],
        Field(
            description='A date/time specifying when the account was last reconciled.'
        ),
    ] = None
    debt_original_balance: Annotated[
        Optional[int],
        Field(
            description='The original debt/loan account balance, specified in milliunits format.'
        ),
    ] = None
    debt_interest_rates: Optional[LoanAccountPeriodicValue] = None
    debt_minimum_payments: Optional[LoanAccountPeriodicValue] = None
    debt_escrow_amounts: Optional[LoanAccountPeriodicValue] = None
    deleted: Annotated[
        bool,
        Field(
            description='Whether or not the account has been deleted.  Deleted accounts will only be included in delta requests.'
        ),
    ]


class SaveAccount(BaseModel):
    name: Annotated[str, Field(description='The name of the account')]
    type: AccountType
    balance: Annotated[
        int,
        Field(description='The current balance of the account in milliunits format'),
    ]


class Data7(BaseModel):
    category: Category


class CategoryResponse(BaseModel):
    data: Data7


class CategoryGroupWithCategories(CategoryGroup):
    categories: Annotated[
        List[Category],
        Field(
            description='Category group categories.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).'
        ),
    ]


class Data9(BaseModel):
    payees: List[Payee]
    server_knowledge: Annotated[int, Field(description='The knowledge of the server')]


class PayeesResponse(BaseModel):
    data: Data9


class Data10(BaseModel):
    payee: Payee


class PayeeResponse(BaseModel):
    data: Data10


class Data11(BaseModel):
    payee: Payee
    server_knowledge: Annotated[int, Field(description='The knowledge of the server')]


class SavePayeeResponse(BaseModel):
    data: Data11


class Data12(BaseModel):
    payee_locations: List[PayeeLocation]


class PayeeLocationsResponse(BaseModel):
    data: Data12


class Data13(BaseModel):
    payee_location: PayeeLocation


class PayeeLocationResponse(BaseModel):
    data: Data13


class SaveTransactionWithOptionalFields(BaseModel):
    account_id: Optional[UUID] = None
    date: Annotated[
        Optional[date],
        Field(
            description='The transaction date in ISO format (e.g. 2016-12-01).  Future dates (scheduled transactions) are not permitted.  Split transaction dates cannot be changed and if a different date is supplied it will be ignored.'
        ),
    ] = None
    amount: Annotated[
        Optional[int],
        Field(
            description='The transaction amount in milliunits format.  Split transaction amounts cannot be changed and if a different amount is supplied it will be ignored.'
        ),
    ] = None
    payee_id: Annotated[
        Optional[UUID],
        Field(
            description='The payee for the transaction.  To create a transfer between two accounts, use the account transfer payee pointing to the target account.  Account transfer payees are specified as `transfer_payee_id` on the account resource.'
        ),
    ] = None
    payee_name: Annotated[
        Optional[str],
        Field(
            description='The payee name.  If a `payee_name` value is provided and `payee_id` has a null value, the `payee_name` value will be used to resolve the payee by either (1) a matching payee rename rule (only if `import_id` is also specified) or (2) a payee with the same name or (3) creation of a new payee.',
            max_length=200,
        ),
    ] = None
    category_id: Annotated[
        Optional[UUID],
        Field(
            description='The category for the transaction.  To configure a split transaction, you can specify null for `category_id` and provide a `subtransactions` array as part of the transaction object.  If an existing transaction is a split, the `category_id` cannot be changed.  Credit Card Payment categories are not permitted and will be ignored if supplied.'
        ),
    ] = None
    memo: Annotated[Optional[str], Field(max_length=500)] = None
    cleared: Optional[TransactionClearedStatus] = None
    approved: Annotated[
        Optional[bool],
        Field(
            description='Whether or not the transaction is approved.  If not supplied, transaction will be unapproved by default.'
        ),
    ] = None
    flag_color: Optional[TransactionFlagColor] = None
    subtransactions: Annotated[
        Optional[List[SaveSubTransaction]],
        Field(
            description='An array of subtransactions to configure a transaction as a split. Updating `subtransactions` on an existing split transaction is not supported.'
        ),
    ] = None


class TransactionSummary(BaseModel):
    id: str
    date: Annotated[
        date, Field(description='The transaction date in ISO format (e.g. 2016-12-01)')
    ]
    amount: Annotated[
        int, Field(description='The transaction amount in milliunits format')
    ]
    memo: Optional[str] = None
    cleared: TransactionClearedStatus
    approved: Annotated[
        bool, Field(description='Whether or not the transaction is approved')
    ]
    flag_color: Optional[TransactionFlagColor] = None
    flag_name: Optional[TransactionFlagName] = None
    account_id: UUID
    payee_id: Optional[UUID] = None
    category_id: Optional[UUID] = None
    transfer_account_id: Annotated[
        Optional[UUID],
        Field(
            description='If a transfer transaction, the account to which it transfers'
        ),
    ] = None
    transfer_transaction_id: Annotated[
        Optional[str],
        Field(
            description='If a transfer transaction, the id of transaction on the other side of the transfer'
        ),
    ] = None
    matched_transaction_id: Annotated[
        Optional[str],
        Field(
            description='If transaction is matched, the id of the matched transaction'
        ),
    ] = None
    import_id: Annotated[
        Optional[str],
        Field(
            description="If the transaction was imported, this field is a unique (by account) import identifier.  If this transaction was imported through File Based Import or Direct Import and not through the API, the import_id will have the format: 'YNAB:[milliunit_amount]:[iso_date]:[occurrence]'.  For example, a transaction dated 2015-12-30 in the amount of -$294.23 USD would have an import_id of 'YNAB:-294230:2015-12-30:1'.  If a second transaction on the same account was imported and had the same date and same amount, its import_id would be 'YNAB:-294230:2015-12-30:2'."
        ),
    ] = None
    import_payee_name: Annotated[
        Optional[str],
        Field(
            description='If the transaction was imported, the payee name that was used when importing and before applying any payee rename rules'
        ),
    ] = None
    import_payee_name_original: Annotated[
        Optional[str],
        Field(
            description='If the transaction was imported, the original payee name as it appeared on the statement'
        ),
    ] = None
    debt_transaction_type: Annotated[
        Optional[DebtTransactionType],
        Field(
            description='If the transaction is a debt/loan account transaction, the type of transaction'
        ),
    ] = None
    deleted: Annotated[
        bool,
        Field(
            description='Whether or not the transaction has been deleted.  Deleted transactions will only be included in delta requests.'
        ),
    ]


class TransactionDetail(TransactionSummary):
    account_name: str
    payee_name: Optional[str] = None
    category_name: Annotated[
        Optional[str],
        Field(
            description="The name of the category.  If a split transaction, this will be 'Split'."
        ),
    ] = None
    subtransactions: Annotated[
        List[SubTransaction],
        Field(description='If a split transaction, the subtransactions.'),
    ]


class HybridTransaction(TransactionSummary):
    type: Annotated[
        Type,
        Field(
            description='Whether the hybrid transaction represents a regular transaction or a subtransaction'
        ),
    ]
    parent_transaction_id: Annotated[
        Optional[str],
        Field(
            description='For subtransaction types, this is the id of the parent transaction.  For transaction types, this id will be always be null.'
        ),
    ] = None
    account_name: str
    payee_name: Optional[str] = None
    category_name: Annotated[
        Optional[str],
        Field(
            description="The name of the category.  If a split transaction, this will be 'Split'."
        ),
    ] = None


class PatchPayeeWrapper(BaseModel):
    payee: SavePayee


class PatchCategoryWrapper(BaseModel):
    category: SaveCategory


class PatchMonthCategoryWrapper(BaseModel):
    category: SaveMonthCategory


class BulkTransactions(BaseModel):
    transactions: List[SaveTransactionWithOptionalFields]


class SaveScheduledTransaction(BaseModel):
    account_id: UUID
    date: Annotated[
        date,
        Field(
            description='The scheduled transaction date in ISO format (e.g. 2016-12-01).  This should be a future date no more than 5 years into the future.'
        ),
    ]
    amount: Annotated[
        Optional[int],
        Field(description='The scheduled transaction amount in milliunits format.'),
    ] = None
    payee_id: Annotated[
        Optional[UUID],
        Field(
            description='The payee for the scheduled transaction.  To create a transfer between two accounts, use the account transfer payee pointing to the target account.  Account transfer payees are specified as `transfer_payee_id` on the account resource.'
        ),
    ] = None
    payee_name: Annotated[
        Optional[str],
        Field(
            description='The payee name for the the scheduled transaction.  If a `payee_name` value is provided and `payee_id` has a null value, the `payee_name` value will be used to resolve the payee by either (1) a payee with the same name or (2) creation of a new payee.',
            max_length=200,
        ),
    ] = None
    category_id: Annotated[
        Optional[UUID],
        Field(
            description='The category for the scheduled transaction. Credit Card Payment categories are not permitted. Creating a split scheduled transaction is not currently supported.'
        ),
    ] = None
    memo: Annotated[Optional[str], Field(max_length=500)] = None
    flag_color: Optional[TransactionFlagColor] = None
    frequency: Optional[ScheduledTransactionFrequency] = None


class ScheduledTransactionSummary(BaseModel):
    id: UUID
    date_first: Annotated[
        date,
        Field(
            description='The first date for which the Scheduled Transaction was scheduled.'
        ),
    ]
    date_next: Annotated[
        date,
        Field(
            description='The next date for which the Scheduled Transaction is scheduled.'
        ),
    ]
    frequency: Frequency
    amount: Annotated[
        int, Field(description='The scheduled transaction amount in milliunits format')
    ]
    memo: Optional[str] = None
    flag_color: Optional[TransactionFlagColor] = None
    flag_name: Optional[TransactionFlagName] = None
    account_id: UUID
    payee_id: Optional[UUID] = None
    category_id: Optional[UUID] = None
    transfer_account_id: Annotated[
        Optional[UUID],
        Field(
            description='If a transfer, the account_id which the scheduled transaction transfers to'
        ),
    ] = None
    deleted: Annotated[
        bool,
        Field(
            description='Whether or not the scheduled transaction has been deleted.  Deleted scheduled transactions will only be included in delta requests.'
        ),
    ]


class ScheduledTransactionDetail(ScheduledTransactionSummary):
    account_name: str
    payee_name: Optional[str] = None
    category_name: Annotated[
        Optional[str],
        Field(
            description="The name of the category.  If a split scheduled transaction, this will be 'Split'."
        ),
    ] = None
    subtransactions: Annotated[
        List[ScheduledSubTransaction],
        Field(description='If a split scheduled transaction, the subtransactions.'),
    ]


class Data22(BaseModel):
    months: List[MonthSummary]
    server_knowledge: Annotated[int, Field(description='The knowledge of the server')]


class MonthSummariesResponse(BaseModel):
    data: Data22


class Data23(BaseModel):
    month: MonthDetail


class MonthDetailResponse(BaseModel):
    data: Data23


class BudgetSummary(BaseModel):
    id: UUID
    name: str
    last_modified_on: Annotated[
        Optional[datetime],
        Field(
            description='The last time any changes were made to the budget from either a web or mobile client'
        ),
    ] = None
    first_month: Annotated[
        Optional[date], Field(description='The earliest budget month')
    ] = None
    last_month: Annotated[
        Optional[date], Field(description='The latest budget month')
    ] = None
    date_format: Optional[DateFormat] = None
    currency_format: Optional[CurrencyFormat] = None
    accounts: Annotated[
        Optional[List[Account]],
        Field(
            description='The budget accounts (only included if `include_accounts=true` specified as query parameter)'
        ),
    ] = None


class BudgetDetail(BudgetSummary):
    accounts: Optional[List[Account]] = None
    payees: Optional[List[Payee]] = None
    payee_locations: Optional[List[PayeeLocation]] = None
    category_groups: Optional[List[CategoryGroup]] = None
    categories: Optional[List[Category]] = None
    months: Optional[List[MonthDetail]] = None
    transactions: Optional[List[TransactionSummary]] = None
    subtransactions: Optional[List[SubTransaction]] = None
    scheduled_transactions: Optional[List[ScheduledTransactionSummary]] = None
    scheduled_subtransactions: Optional[List[ScheduledSubTransaction]] = None


class Data4(BaseModel):
    accounts: List[Account]
    server_knowledge: Annotated[int, Field(description='The knowledge of the server')]


class AccountsResponse(BaseModel):
    data: Data4


class Data5(BaseModel):
    account: Account


class AccountResponse(BaseModel):
    data: Data5


class PostAccountWrapper(BaseModel):
    account: SaveAccount


class Data6(BaseModel):
    category_groups: List[CategoryGroupWithCategories]
    server_knowledge: Annotated[int, Field(description='The knowledge of the server')]


class CategoriesResponse(BaseModel):
    data: Data6


class Data14(BaseModel):
    transactions: List[TransactionDetail]
    server_knowledge: Annotated[int, Field(description='The knowledge of the server')]


class TransactionsResponse(BaseModel):
    data: Data14


class Data15(BaseModel):
    transactions: List[HybridTransaction]
    server_knowledge: Annotated[
        Optional[int], Field(description='The knowledge of the server')
    ] = None


class HybridTransactionsResponse(BaseModel):
    data: Data15


class ExistingTransaction(SaveTransactionWithOptionalFields):
    pass


class NewTransaction(SaveTransactionWithOptionalFields):
    import_id: Annotated[
        Optional[str],
        Field(
            description='If specified, a new transaction will be assigned this `import_id` and considered "imported".  We will also attempt to match this imported transaction to an existing "user-entered" transaction on the same account, with the same amount, and with a date +/-10 days from the imported transaction date.<br><br>Transactions imported through File Based Import or Direct Import (not through the API) are assigned an import_id in the format: \'YNAB:[milliunit_amount]:[iso_date]:[occurrence]\'. For example, a transaction dated 2015-12-30 in the amount of -$294.23 USD would have an import_id of \'YNAB:-294230:2015-12-30:1\'.  If a second transaction on the same account was imported and had the same date and same amount, its import_id would be \'YNAB:-294230:2015-12-30:2\'.  Using a consistent format will prevent duplicates through Direct Import and File Based Import.<br><br>If import_id is omitted or specified as null, the transaction will be treated as a "user-entered" transaction. As such, it will be eligible to be matched against transactions later being imported (via DI, FBI, or API).',
            max_length=36,
        ),
    ] = None


class SaveTransactionWithIdOrImportId(SaveTransactionWithOptionalFields):
    id: Annotated[
        Optional[str],
        Field(
            description='If specified, this id will be used to lookup a transaction by its `id` for the purpose of updating the transaction itself. If not specified, an `import_id` should be supplied.'
        ),
    ] = None
    import_id: Annotated[
        Optional[str],
        Field(
            description='If specified, this id will be used to lookup a transaction by its `import_id` for the purpose of updating the transaction itself. If not specified, an `id` should be supplied.  You may not provide both an `id` and an `import_id` and updating an `import_id` on an existing transaction is not allowed.',
            max_length=36,
        ),
    ] = None


class Data16(BaseModel):
    transaction_ids: Annotated[
        List[str], Field(description='The transaction ids that were saved')
    ]
    transaction: Optional[TransactionDetail] = None
    transactions: Annotated[
        Optional[List[TransactionDetail]],
        Field(
            description='If multiple transactions were specified, the transactions that were saved'
        ),
    ] = None
    duplicate_import_ids: Annotated[
        Optional[List[str]],
        Field(
            description='If multiple transactions were specified, a list of import_ids that were not created because of an existing `import_id` found on the same account'
        ),
    ] = None
    server_knowledge: Annotated[int, Field(description='The knowledge of the server')]


class SaveTransactionsResponse(BaseModel):
    data: Data16


class Data17(BaseModel):
    transaction: TransactionDetail


class TransactionResponse(BaseModel):
    data: Data17


class Data20(BaseModel):
    scheduled_transactions: List[ScheduledTransactionDetail]
    server_knowledge: Annotated[int, Field(description='The knowledge of the server')]


class ScheduledTransactionsResponse(BaseModel):
    data: Data20


class Data21(BaseModel):
    scheduled_transaction: ScheduledTransactionDetail


class ScheduledTransactionResponse(BaseModel):
    data: Data21


class PostScheduledTransactionWrapper(BaseModel):
    scheduled_transaction: SaveScheduledTransaction


class Data1(BaseModel):
    budgets: List[BudgetSummary]
    default_budget: Optional[BudgetSummary] = None


class BudgetSummaryResponse(BaseModel):
    data: Data1


class Data2(BaseModel):
    budget: BudgetDetail
    server_knowledge: Annotated[int, Field(description='The knowledge of the server')]


class BudgetDetailResponse(BaseModel):
    data: Data2


class PutTransactionWrapper(BaseModel):
    transaction: ExistingTransaction


class PostTransactionsWrapper(BaseModel):
    transaction: Optional[NewTransaction] = None
    transactions: Optional[List[NewTransaction]] = None


class PatchTransactionsWrapper(BaseModel):
    transactions: List[SaveTransactionWithIdOrImportId]
